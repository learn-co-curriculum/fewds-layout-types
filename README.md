# Layout Types

1. Scaling elements with different property attributes.
2. Controlling sizes with min and max.

Next, we're going to talk about scaling elements. When sizing elements in a layout, you can use fixed sizing using `px`, elastic sizing using `em`, or fluid sizing using `%`. and we'll also look at using min and max sizing properties. 

With a fixed layout, all columns are specified using pixels. In this example, a 520px column and two 200px columns are separated by 20 pixels of margin, which adds up to 960px total. One of the advantages of using a fixed layout is that the elements on the screen will be exactly the same size on all screens, large and small. The main downside to a fixed width layout is that it could create excessive white space for users that have very large screens. The content wouldn't be making use of more of the screen real estate. Another downside is that on smaller screens like mobile, if your content is size larger than the screen itself, it may require horizontal scrolling, and the user will have to scroll over to see the rest of the content that's getting chopped off. Fixed layouts are not necessarily ideal for responsive designs that are meant to change the content size for different sized screens. 

You can create elastic layouts where the columns are sized using ems and the columns will be in proportion to the text size, changing up and down. The advantanges to this is when you scale up and down, you will be able to keep the containers in proportion to their text content. The main downside to this is that as text gets larger, it may cause their parent containers to start to bump into each other, so this requires a lot of testing and checking out the layout on different
sized devices and text sizes.

With creating fluid layouts, the column widths use percentages that are based on a percentage of space within the parent container, or the percentage within the browser window. One of the advantages of using a fluid layout is that this will make full use of the screen, and it will eliminate horizontal scroll bars at smaller screen resolutions. The main downside to this we have less control over what the user sees with regards to container sizes, and where text and media will begin to wrap. This creates design flaws. 

You also have the ability to set thresholds using the min and max properties so you can set a default width and `max-width`, and you can also set a height and `max-height`. What that will do is set up a starting and stopping point for when the container will begin to grow, and when it will stop growing. If you have a min width set to 960px, as the screen scales down, the browser is going to allow the element to be fluid until it reaches the 960px amount in width. At that point it's going to stop shrinking and become a fixed-sized element. This means that it will not get any smaller than 960px. If you start opening up the browser wider and wider, at 1080px, which is the max width, it will stop growing and you'll start to see white space appear. In between the min and max, this element will behave as though it is a fluid element. Outside of those boundaries at a  maximum of 1080px and a minimum of 960px, it will begin to act like an element that has a static or a fixed pixel amount. 

<iframe width="100%" height="300" src="//jsfiddle.net/flatiron_school/99Tgm/embedded/" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>

In this example, we've created a div and it has a background color of aqua. It has some padding some margin and with a font size of 1em. Also, there are some classes here that will apply different types of widths. The container that is called fixed size has a width of 200px and a  class called elastic size, where the width is set in ems. There is another container where the width is set in percent, and another class that has a min and max width set. The element that has the class `fixed-size` has a width of 200px. This element will stay the same size on any size screen. When the screen gets smaller than the element you will need to use the horizontal scroll bar to scroll over and see the rest of the content.

In order to calculate the exact same
size using ems, you would take 200 pixels, which is the size that we're matching, and divided it by 16px, which represents 1em. That leaves us with 12.5em, so 12.5em is the equivalent of 200 pixels. When you scale the text up and down, unlike the pixels, the container is also going to scale proportionally with that text. The body font size is currently set to 100%. If you bump it up to 200%, you'll notice that the fixed pixel element that the text has gotten larger, but the element has stayed 200px in size. In the  elastic layout where the width is in ems, when the text gets larger, the container also gets larger proportionally. 

In the 3rd div, we have it set to fluid size, which will have a width set in percent. This container is set to 70% of the screen. When the size is changed, it's going to stretch or shrink depending on how much available space there is. When it's scaled down very small you're not going to see the horizontal scroll bars as you would for the fixed and elastic containers. The scroll bars are not necessary for fluid because fluid is snapping to the appropriate size. 

The last div has the class `threshold-size,` which will apply a min width of 500px and a max dash width of 900px. With the min and max widths applied, when the screen is resized larger than 900px, it stops growing. When it's made smaller it becomes fluid and starts shrinking down. Once it gets under 500px then it'll need the scroll bars to scroll over. It stops shrinking at 500px in the same way that it will stop growing at the max width, which is 900px. 

Much like the width attribute, the height attribute also allows for its sizing based on pixels, ems, percents, or min and Max values. The div with filler text is currently only as tall as the content inside, because a height for this element has not been specified. In the abscense of specifying a height, which is the same as setting the height to `auto` it will only be as tall as the content dictates. To demonstrate that this is truel, if more content is added inside the element, you will see that it will grow in height. You also have the ability to set a fixed amount of height. For example, if there's a height of 300px, then you'll see that size regardless of the length of the content. The main drawback of this is that if at some point you content scales larger than the size of the height, you'll notice that the content starts to overflow outside of this element.
